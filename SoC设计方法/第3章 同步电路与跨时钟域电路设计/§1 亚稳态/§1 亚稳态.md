## 亚稳态概念
### 建立时间和保持时间
建立时间是指在时钟有效沿（下图为上升沿）之前，数据输入端信号必须保持稳定的最短时间。
![[Pasted image 20240512223110.png]]
保持时间是指在时钟有效沿（下图为上升沿）之后，数据输入端信号必须保持稳定的最短时间。hold time时序检查确保新数据不会在触发器稳定输出初始数据之前过早到达D端而覆盖其初始数据。
![[Pasted image 20240512223135.png]]

### 亚稳态概念
器件（寄存器）在保存数据的时间里无法判断数据逻辑的状况
### 亚稳态产生原因
在时钟变化的这段时间里，寄存器将对数据进行锁存。如果数据在这段时间内发生了变化，对于寄存器来说也就无法识别应该锁存哪个数据，到底是变化前的还是变化后的，寄存器的输出也将变得无法预测。因此，数据在建立时间和保持时间内必须保持稳定不变。

从更加宏观的设计角度来看，<font color="#00b0f0">异步逻辑是亚稳态出现的重要原因。</font>

在正常的同步电路中，亚稳态出现的可能性很小，除非时钟的设计有很大问题（比如时钟延迟、时钟抖动、时钟偏斜很严重）。而异步逻辑则很容易出现亚稳态。异步逻辑没有统一的时钟，各级触发器的状态变化不是在统一的时钟作用下完成的（触发器的状态变化不是同时发生的）。没有统一的时钟也就意味着控制信号随时可能发生变化，想要满足建立时间和保持时间的约束当然也就变的十分困难。
要解决这些原因，就要跨时钟域电路的帮助了
### MTBF（Mean Time Between Failures，平均故障间隔时间）
![[Pasted image 20240513204247.png]]
![[Pasted image 20240513204146.png]]
![[Pasted image 20240513204402.png]]

## 跨时钟域电路

### 1.单bit信号跨时钟域（分为快—>慢和慢->快）

#### 慢->快（电平同步器、边沿检测同步器）
##### 1.电平同步器（双锁存器法）
###### 双锁存器法概念
在一个信号从一个时钟域进入另一个时钟域之前，将该信号用新时钟域控制的两个锁存器连续锁存两次，最后得到的结果就能满足实际应用的要求。这种方法也被通俗地称为“打两拍”
![[Pasted image 20240512224302.png]]

###### 有效条件
![[Pasted image 20240513210119.png]]
第一级触发器进入亚稳态的恢复时间 + 第二级触发器建立时间 <= 时钟周期
输入脉冲宽度 > 同步时钟周期 + 第一级触发器的保持时间
更保险的说法：脉冲宽度 > 两倍同步时钟周期
常用于慢->快时钟域
###### MTBF计算
b_dat2 的 MTBF 为
![[Pasted image 20240512224845.png]]
###### 优缺点
优点：结构简单、易于实现、面积消耗较少  
缺点：增加了两个触发器的延时 ,当快->慢时，容易造成慢时钟采样丢失（还未来得及采样，数据已经变化了），故常用于慢->快
该方法只是降低发生概率，<font color="#ff0000">不能从根本上进行去除亚稳态</font>
##### 2.边沿检测同步器
###### 大体思路
要实现边沿检测，最直接的想法是用**两级寄存器**，第二级寄存器锁存住某个时钟上升沿到来时的输入电平，第一级寄存器锁存住下一个时钟沿到来时的输入电平，如果这两个寄存器锁存住的电平信号不同，就说明检测到了边沿，具体是上升沿还是下降沿可以通过组合逻辑来实现。
###### 边沿检测同步器
![[Pasted image 20240513212205.png]]
![[Pasted image 20240512230657.png]]
适用条件
![[Pasted image 20240513212559.png]]

###### 边沿检测原因和适用条件
边沿检测原因：慢时钟的一个周期信号在快时钟看来就是几个信号周期，所以检测边沿是最合理的，检测边沿的上升或者下降。
适用条件： 输入数据宽度 **>** 同步时钟周期+Th（最安全的是大于两个同步时钟周期）
#### 快->慢（脉冲同步器）
脉冲同步器
![[Pasted image 20240513212918.png]]
![[Pasted image 20240513213002.png]]

### 三种同步器比较
![[Pasted image 20240513213700.png]]
### 结绳法
结绳法适合任何时钟域过渡
### 2.多bit信号跨时钟域传输
#### 数据流和指示信号的不同
数据流有连续性
要求具有较快的传输速度
#### 数据流传输解决方案
##### 1.SRAM（这里不讲）
##### 2.FIFO（先进先出）
###### 和普通存储器的区别
没有外部读写地址线（使用简单）
###### FIFO缺点
![[Pasted image 20240514201701.png]]

###### 主要结构
![[Pasted image 20240514202128.png]]
![[Pasted image 20240514202952.png]]
###### 用途
1.异步FIFO读写分别采用相互异步的不同时钟
2.对于不同宽度的数据接口也可以用FIFO
###### FIFO空满信号生成机制
FIFO空满的判断都是基于读指针和写指针来判断的，在读写指针指向同一位置的时候，有三种情况：
1.复位
2.FIFO满
3.FIFO空
那怎么区别这三种情况呢？
这个时候，我们在读和写指针中各加1个额外的位（MSB折回标志位）
在当写（读）指针增加并越过最后一个FIFO地址时，其MSB位+1。
此时
当读写指针的MSB位不相同的时候证明写指针比读指针多折回了一次。为什么是写比读多而不是读比写多，这个要知道FIFO在刚开始空的情况下要先写了数据才能开始读。
如果两个MSB位相同且其余位相等说明FIFO为空。

###### 格雷码
在FIFO空满信号生成机制中我们得知要将读写指针进行比较
![[Pasted image 20240514211912.png]]
可以看到，wptr（写指针）和rptr（读指针）通过两级同步器传入判断空和判断满的模块中进行比较，这也就意味着：
读指针被传递到了写时钟域
写指针被传递到了读时钟域

由于采用了两级同步器只能传输单bit信号，所以像地址这种多bit变化的信号是无法通过两级同步器进行传输的，因此我们引入了格雷码
![[Pasted image 20240514212822.png]]

格雷码的编码
第一步，改变最右边的位元值；
第二步，改变右起第一个为1的位元的左边位元；
第三步，第四步重复第一步和第二步，直到所有的格雷码产生完毕（换句话说，已经走了(2^n) - 1 步）。
例如
假设产生3位元的格雷码，原始值位 000
　　第一步：改变最右边的位元值： 001
　　第二步：改变右起第一个为1的位元的左边位元： 011
重复1：
　　第三步：改变最右边的位元值： 010
　　第四步：改变右起第一个为1的位元的左边位元： 110
重复2：
　　第五步：改变最右边的位元值： 111
　　第六步：改变右起第一个为1的位元的左边位元： 101
重复3：
　　第七步：改变最右边的位元值： 100     //已经走了(2^n) - 1  = 7步，完成所有码字的产生。

![[Pasted image 20240514223124.png]]




格雷码转二进制
![[Pasted image 20240514222758.png]]


###### 格雷码下的空满判断
首先空的判断还是读指针和写指针相等(包括MSB)
满的判断
![[Pasted image 20240514225015.png]]

###### FIFO深度设计
一道题来看这个深度设计问题
![[Pasted image 20240514230312.png]]
我们只需要考虑最坏的情况，就是重载时的情况
重载时，假设第1个100个时钟前20个时钟不写入数据，第2个100个时钟最后20个时钟不写入数据，那这样最多一次性写入160个数据